@page "/posts"
@inject IPostService Posts
@inject NavigationManager Nav

<h3>Posts</h3>

<!-- ===== SORT + PAGE SIZE ===== -->
<div class="mb-2" style="display:flex; gap:16px; align-items:center;">
    <div>
        <label>Sort: </label>
        <select value="@sort" @onchange="OnSortChanged">
            <option value="createdDesc">Newest first</option>
            <option value="createdAsc">Oldest first</option>
        </select>
    </div>

    <div>
        <label>Page size: </label>
        <select value="@pageSize" @onchange="OnPageSizeChanged">
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="25">25</option>
        </select>
    </div>

    

    <a href="/posts/add" style="margin-left:auto">+ Add Post</a>
</div>

<!-- Filter by Title -->
<div class="mb-2">
    <label>Filter by Title: </label>
    <input @bind="titleFilter" placeholder="e.g. hello" />
    <button @onclick="SearchByTitle">Search</button>
</div>

<!-- Filter by UserId (integer) -->
<div class="mb-2">
    <label>Filter by UserId (integer): </label>
    <input @bind="userIdText" placeholder="e.g. 1" />
    <button @onclick="SearchByUserId">Search</button>
</div>

<!-- Clear filters -->
<div class="mb-2">
    <button @onclick="LoadAll">Clear filters</button>
</div>

<!-- Display errors if something went wrong -->
@if (!string.IsNullOrWhiteSpace(error))
{
    <p style="color:red">@error</p>
}

<!-- ===== RENDER: filters vs. pagination ===== -->
@{
    bool hasTitle = !string.IsNullOrWhiteSpace(titleFilter);
    bool hasUser  = int.TryParse(userIdText, out _);
    bool filtersActive = hasTitle || hasUser;
}

@if (pageData is null)
{
    <p>Loading...</p>
}
else if (pageData.Items.Count == 0)
{
    <p>No posts.</p>
}
else
{
    <p>
        Showing <b>@startIdx–@endIdx</b> of <b>@pageData.TotalCount</b>
        (Page <b>@(page)</b>)
    </p>

    <table>
        <thead>
            <tr>
                <th style="text-align:left;">Id</th>
                <th style="text-align:left;">Title</th>
                <th style="text-align:left;">UserId</th>
                <th style="text-align:left;">Open</th>
                <th style="text-align:left;">Actions</th>
            </tr>
        </thead>
        <tbody>
        @foreach (var p in pageData.Items)
        {
            <tr>
                <td>@p.Id</td>
                <td>@p.Title</td>
                <td>@p.UserId</td>
                <td><a href="@($"/posts/{p.Id}")">Details</a></td>
                <td>
                    @if (p.UserId == 1)
                    {
                        <button @onclick="@(()=> Nav.NavigateTo($"/posts/{p.Id}/edit"))">Edit</button>
                        @if (confirmDeleteId != p.Id)
                        {
                            <button style="margin-left:6px" @onclick="@(()=> confirmDeleteId = p.Id)">Delete</button>
                        }
                        else
                        {
                            <span style="margin-left:6px">
                                Sure?
                                <button @onclick="@(()=> DeletePaged(p.Id))">Yes</button>
                                <button style="margin-left:6px" @onclick="@(()=> confirmDeleteId = null)">No</button>
                            </span>
                        }
                    }
                    else { <span style="color:#888">—</span> }
                </td>
            </tr>
        }
        </tbody>
    </table>

    <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
        <button @onclick="Prev" disabled="@isPrevDisabled">Prev</button>
        <button @onclick="Next" disabled="@isNextDisabled">Next</button>
        <span>Page <b>@(page)</b></span>
    </div>
}


@code {
    // === COMPONENT STATE ===

    // ======= Shared =======
    private string? error;          // last error to display
    private int? confirmDeleteId;   // ID of the post for which we show delete confirmation
    private string? titleFilter;    // entered title filter
    private string? userIdText;     // entered userId as text (to avoid exceptions when parsing)
    // ======= Pagination =======

    // Backend: GET /posts?page=1&pageSize=10&sort=createdDesc => PagedResult<PostDto> { Items, TotalCount }
    private PagedResult<PostDto>? pageData;

    private int page = 1;          // numer strony (1-based)
    private int pageSize = 10;     // 5 / 10 / 20
    private string sort = "createdDesc"; // "createdDesc" | "createdAsc"


    private int startIdx => (pageData is null || pageData.TotalCount == 0) ? 0 : ((page - 1) * pageSize) + 1;
    private int endIdx   => (pageData is null) ? 0 : Math.Min(page * pageSize, pageData.TotalCount);

    private bool isPrevDisabled => page <= 1;
    private bool isNextDisabled => pageData is null || (page * pageSize) >= pageData.TotalCount;

    
    // === LIFECYCLE: start with loading all posts ===
    protected override async Task OnInitializedAsync()
    {
        await ReloadPaged();
    }

    // ======= Actions: =======

    private async Task LoadAll()
    {
        titleFilter = null;
        userIdText = null;
        page = 1;
        await ReloadPaged();
    }

    private async Task ClearAll()
    {
        titleFilter = null;
        userIdText = null;
        page = 1;
        await ReloadPaged();

    }

    private async Task OnSortChanged(ChangeEventArgs e)
    {
        sort = e?.Value?.ToString() ?? sort;
        page = 1;
        await ReloadPaged();
    }

    private async Task OnPageSizeChanged(ChangeEventArgs e)
    {
        if (!int.TryParse(e?.Value?.ToString(), out var ps)) ps = pageSize;
        pageSize = ps;
        page = 1;
        await ReloadPaged();
    }
    
    // Search by title
    private async Task SearchByTitle()
    {
        error = null;
        confirmDeleteId = null;
        if (string.IsNullOrWhiteSpace(titleFilter)) { await ClearAll(); return; }
        try
        {
            page = 1;
            await ReloadPaged();

        }
        catch (Exception ex)
        {
            error = ex.Message;
        }
    }

    // Search by userId
    private async Task SearchByUserId()
    {
        error = null; confirmDeleteId = null;
        if (!int.TryParse(userIdText, out var uid)) { error = "UserId must be an integer."; return; }
        try
        {
            page = 1;
            await ReloadPaged();
        }
        catch (Exception ex)
        {
            error = ex.Message;
        }
    }

    private async Task ReloadPaged()
    {
        error = null;
        confirmDeleteId = null;

        try
        {
            int? uid = int.TryParse(userIdText, out var parsed) ? parsed : (int?)null;
            pageData = await Posts.GetPageAsync(page, pageSize, sort, titleFilter, uid);


            // If we are out of range (e.g. after deleting records)
            var maxPage = Math.Max(1, (int)Math.Ceiling((pageData.TotalCount) / (double)pageSize));
            if (page > maxPage)
            {
                page = maxPage;
                pageData = await Posts.GetPageAsync(page, pageSize, sort);
            }
        }
        catch (Exception ex)
        {
            error = ex.Message;
            pageData = new PagedResult<PostDto> { Items = new List<PostDto>(), TotalCount = 0 };
        }
    }

    private async Task Prev()
    {
        if (page <= 1) return;
        page--;
        await ReloadPaged();
    }

    private async Task Next()
    {
        if (pageData is null) return;
        if ((page * pageSize) >= pageData.TotalCount) return;

        page++;
        await ReloadPaged();
    }

    // ======= Delete Post =======

    private async Task DeletePaged(int id)
    {
        error = null;
        try
        {
            await Posts.DeleteAsync(id);
            confirmDeleteId = null;
            await ReloadPaged(); // refresh current page; will go back if empty
        }
        catch (Exception ex)
        {
            error = ex.Message;
            confirmDeleteId = null;
        }
    }

    // ======= Helpers =======
    private IEnumerable<PostDto> ApplyFilterSorting(IEnumerable<PostDto>? src)
    {
        var list = src ?? Enumerable.Empty<PostDto>();
        // Brak CreatedAt -> używamy Id jako proxy „created”
        return sort == "createdAsc"
            ? list.OrderBy(p => p.Id)
            : list.OrderByDescending(p => p.Id); // domyślnie: newest first
    }

}